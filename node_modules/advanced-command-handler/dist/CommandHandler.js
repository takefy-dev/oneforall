"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandHandler = void 0;
const discord_js_1 = require("discord.js");
const events_1 = require("events");
const fs_1 = require("fs");
const path_1 = require("path");
const defaultCommands = __importStar(require("./defaults/commands/index"));
const defaultEvents = __importStar(require("./defaults/events/index"));
const Logger_1 = require("./utils/Logger");
const AdvancedClient_1 = require("./classes/AdvancedClient");
const Command_1 = require("./classes/Command");
const CommandHandlerError_1 = require("./classes/CommandHandlerError");
const Event_1 = require("./classes/Event");
var CommandHandler;
(function (CommandHandler) {
    /**
     * The version of the handler.
     */
    CommandHandler.version = require('../package.json').version;
    /**
     * The event emitter for the CommandHandler.
     *
     * @eventProperty
     */
    CommandHandler.emitter = new events_1.EventEmitter();
    /**
     * The commands registered by the CommandHandler.
     */
    CommandHandler.commands = new discord_js_1.Collection();
    /**
     * The cooldowns mapped by ID and cooldown user.
     *
     * **A simple explication** :<br>
     * When a user executes a command with a cooldown, a new value is added.
     * ```ts
     * [ID]: {
     *    [commandName]: {
     *        executedAt: Date,
     *        cooldown: [command cooldown]
     *    }
     * }
     * ```
     */
    CommandHandler.cooldowns = new discord_js_1.Collection();
    /**
     * The events registered by the CommandHandler.
     *
     * @remarks
     * These events may not be bound to the {@link client}.
     */
    CommandHandler.events = new discord_js_1.Collection();
    CommandHandler.commandsDir = '';
    CommandHandler.eventsDir = '';
    CommandHandler.owners = [];
    CommandHandler.prefixes = [];
    /**
     * The client of the handler, null before {@link launch} function executed.
     */
    CommandHandler.client = null;
    /**
     * @typeParam K - Events names for CommandHandler.
     * @param eventName - The event name.
     * @param fn - The callback to execute.
     */
    function on(eventName, fn) {
        CommandHandler.emitter.on(eventName, fn);
    }
    CommandHandler.on = on;
    /**
     * @param eventName - The event name.
     * @param args - The arguments to pass.
     */
    function emit(eventName, ...args) {
        CommandHandler.emitter.emit(eventName, args);
    }
    CommandHandler.emit = emit;
    /**
     * Add the defaults events to your CommandHandler.
     *
     * @remarks
     * Must use after {@link CommandHandler.create}.
     *
     * @returns It returns itself so that afterward you can use the other functions.
     */
    function setDefaultEvents() {
        Logger_1.Logger.info('Loading default events.', 'Loading');
        for (let event of Object.values(defaultEvents)) {
            CommandHandler.events.set(event.default.name, event.default);
            Logger_1.Logger.comment(`Default ${Logger_1.Logger.setColor('green', event.default.name) + Logger_1.Logger.setColor('comment', ' event loaded.')}`, 'Loading');
        }
        Logger_1.Logger.info(`Default events loaded. (${Object.values(defaultEvents).length})`, 'Loading');
        return CommandHandler;
    }
    CommandHandler.setDefaultEvents = setDefaultEvents;
    /**
     * Add the defaults commands to your CommandHandler.
     *
     * @remarks
     * Must use after {@link CommandHandler.create}.
     *
     * @returns It returns itself so that afterward you can use the other functions .
     */
    function setDefaultCommands() {
        Logger_1.Logger.info('Loading default commands.', 'Loading');
        for (let command of Object.values(defaultCommands)) {
            CommandHandler.commands.set(command.default.name, command.default);
            Logger_1.Logger.comment(`Default ${Logger_1.Logger.setColor('green', command.default.name) + Logger_1.Logger.setColor('comment', ' command loaded.')}`, 'Loading');
        }
        Logger_1.Logger.info(`Default commands loaded. (${Object.keys(defaultCommands)})`, 'Loading');
        return CommandHandler;
    }
    CommandHandler.setDefaultCommands = setDefaultCommands;
    /**
     * Creates a new CommandHandler, wrap up the last one.
     *
     * @param options - Options for creating a new CommandHandler.
     * @returns It returns itself so that afterward you can use the other functions.
     */
    function create(options) {
        Logger_1.Logger.log(`Advanced Command Handler ${CommandHandler.version} by Ayfri.`, 'Loading', 'red');
        CommandHandler.commandsDir = options.commandsDir ?? '';
        CommandHandler.eventsDir = options.eventsDir ?? '';
        CommandHandler.owners = options.owners ?? [];
        CommandHandler.prefixes = options.prefixes ?? [];
        if (!CommandHandler.commandsDir)
            Logger_1.Logger.warn("No 'commandsDir' specified, commands apart default commands won't load.");
        if (!CommandHandler.eventsDir)
            Logger_1.Logger.warn("No 'eventsDir' specified, events apart default events won't load.");
        process.on('warning', error => Logger_1.Logger.error(`An error occurred. \n${error.stack}`));
        process.on('uncaughtException', error => Logger_1.Logger.error(`An error occurred. \n${error.stack}`));
        emit('create', options);
        return CommandHandler;
    }
    CommandHandler.create = create;
    /**
     * Launches the CommandHandler, log in the client and load commands/events.
     *
     * @param options - Options for launching the CommandHandler, see {@link CreateCommandHandlerOptions}.
     * @returns Itself in a promise.
     */
    async function launch(options) {
        CommandHandler.client = new AdvancedClient_1.AdvancedClient(options.token, options.clientOptions ?? {});
        emit('launch');
        try {
            await loadCommands(CommandHandler.commandsDir);
            await loadEvents(CommandHandler.eventsDir);
            Logger_1.Logger.comment('Binding events to client.', 'Binding');
            CommandHandler.events.forEach(event => {
                event.bind(CommandHandler.client);
            });
            Logger_1.Logger.info(`${CommandHandler.client?.eventNames().length ?? 0} events loaded & bind.`, 'Loading');
        }
        catch (e) {
            Logger_1.Logger.error(e.stack, 'Loading');
        }
        await CommandHandler.client.login(options.token);
        CommandHandler.prefixes.push(`<@${CommandHandler.client?.user?.id}> `);
        CommandHandler.prefixes.push(`<@!${CommandHandler.client?.user?.id}> `);
        CommandHandler.owners.push((await CommandHandler.client.fetchApplication()).owner?.id ?? '');
        emit('launched');
        return CommandHandler;
    }
    CommandHandler.launch = launch;
    /**
     * Get the prefix from the prefixes defined in {@link CommandHandler.launch} or null.
     *
     * @param message - The message to get the prefix for.
     * @returns The prefix found or null if not.
     */
    function getPrefixFromMessage(message) {
        return CommandHandler.prefixes.find(prefix => message.content.startsWith(prefix)) ?? null;
    }
    CommandHandler.getPrefixFromMessage = getPrefixFromMessage;
    /**
     * Load a command from the directory & filename.
     *
     * @param path - The directory to get the command from.
     * @param name - The filename of the command.
     */
    async function loadCommand(path, name) {
        let command = await Promise.resolve().then(() => __importStar(require(path_1.join(process.cwd(), `./${path}/${name}`))));
        if ('default' in command && command.default instanceof Command_1.Command)
            command = command.default;
        if (!command)
            throw new Error(`Command given name or path is not valid.\nPath : ${path}\nName:${name}`);
        if (command.category === 'None')
            command.category = path.split(/[\\/]/).pop();
        const invalidPermissions = command.getInvalidPermissions();
        if (invalidPermissions.client.length > 0)
            throw new CommandHandlerError_1.CommandHandlerError(`Invalid client permissions for '${command.name}' command.\nInvalid Permissions: '${invalidPermissions.client.sort().join(',')}'`, 'Loading');
        if (invalidPermissions.user.length > 0)
            throw new CommandHandlerError_1.CommandHandlerError(`Invalid user permissions for '${command.name}' command.\nInvalid Permissions: '${invalidPermissions.user.sort().join(',')}'`, 'Loading');
        CommandHandler.commands.set(command.name, command);
        emit('loadCommand', command);
        Logger_1.Logger.comment(`Loading the command : ${Logger_1.Logger.setColor('gold', name)}`, 'Loading');
    }
    CommandHandler.loadCommand = loadCommand;
    /**
     * Load all the commands from a directory.
     *
     * @remarks
     * The path must be a directory containing sub-directories.
     *
     * @param path - The path of the directory to load the commands from.
     */
    async function loadCommands(path) {
        if (!path)
            return;
        const dirs = await fs_1.promises.readdir(path);
        Logger_1.Logger.info('Loading commands.', 'Loading');
        Logger_1.Logger.comment(`Categories : (${dirs.length})`, 'Loading');
        if (dirs) {
            for (const dir of dirs) {
                const files = await fs_1.promises.readdir(path_1.join(process.cwd(), `${path}/${dir}`));
                if (files.length === 0)
                    continue;
                Logger_1.Logger.comment(`Commands in the category '${dir}' : (${files.length})`, 'Loading');
                for (const file of files) {
                    await loadCommand(`${path}/${dir}`, file);
                }
            }
        }
        Logger_1.Logger.info(`${CommandHandler.commands.size} commands loaded.`, 'Loading');
    }
    CommandHandler.loadCommands = loadCommands;
    /**
     * Load all the events from a directory.
     *
     * @param path - The path of the directory to load the events from.
     */
    async function loadEvents(path) {
        if (!path)
            return;
        const files = await fs_1.promises.readdir(path);
        Logger_1.Logger.info('Loading events.', 'Loading');
        Logger_1.Logger.comment(`Events : (${files.length})`, 'Loading');
        if (files) {
            for (const file of files) {
                let event = await Promise.resolve().then(() => __importStar(require(path_1.join(process.cwd(), `${path}/${file}`))));
                if ('default' in event && event.default instanceof Event_1.Event)
                    event = event.default;
                if (!event)
                    throw new Error(`Command given name or path is not valid.\nPath : ${path}\nName:${file}`);
                CommandHandler.events.set(event.name, event);
                Logger_1.Logger.comment(`Event ${event.name} loading : ${Logger_1.Logger.setColor('gold', `${file.split('.')[0]}.js`)}`, 'Loading');
            }
        }
    }
    CommandHandler.loadEvents = loadEvents;
})(CommandHandler = exports.CommandHandler || (exports.CommandHandler = {}));
