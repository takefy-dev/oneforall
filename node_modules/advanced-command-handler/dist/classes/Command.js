"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = exports.Tag = void 0;
const discord_js_1 = require("discord.js");
const CommandHandler_1 = require("../CommandHandler");
const utils_1 = require("../utils/utils");
/**
 * # How tags should works ?
 *
 * When using commands, you want certain commands to only run on a server or in DM etc.<br>
 * Most of other CommandHandlers uses boolean properties like `guildOnly`.<br>
 * To avoid having a ton of these, I imagined a system where you have command tags and for every calls, tags for the command are verified one by one.<br>
 * And this system works very smoothly !<br>
 * So if you're using the default message event
 * ({@link https://github.com/Ayfri/Advanced-Command-Handler/wiki/Defaults#defaults-events | see how to use defaults events }), tags will be checked.
 *
 * @example
 * ```ts
 * if (command.tags.includes(Tag.guildOnly) && !message.guild) {
 *     message.channel.send(`You must be on a guild to execute the ${command.name} command !`);
 * }
 * ```
 */
var Tag;
(function (Tag) {
    /**
     * Tag for commands to only run on a guild.
     */
    Tag["guildOnly"] = "guildOnly";
    /**
     * Tag for commands to only run if author is an owner defined in {@link CommandHandler.owners}.
     */
    Tag["ownerOnly"] = "ownerOnly";
    /**
     * Tag for commands to only run on a guild and in an NSFW channel.
     */
    Tag["nsfw"] = "nsfw";
    /**
     * Tag for commands to only run on a guild and if the author is the owner of the guild.
     */
    Tag["guildOwnerOnly"] = "guildOwnerOnly";
    /**
     * Tag for commands to only run in DM.
     */
    Tag["dmOnly"] = "dmOnly";
})(Tag = exports.Tag || (exports.Tag = {}));
class Command {
    /**
     * @param options - The options for the command.
     * @param runFunction - The function to run when executing the command.
     */
    constructor(options, runFunction) {
        this.name = options.name;
        this.run = runFunction;
        this.description = options.description ?? '';
        this.usage = options.usage ?? '';
        this.category = options.category ?? 'None';
        this.aliases = options.aliases ?? [];
        this.clientPermissions = options.clientPermissions ?? ['SEND_MESSAGES'];
        this.userPermissions = options.userPermissions ?? ['SEND_MESSAGES'];
        this.channels = options.channels ?? [];
        this.tags = options.tags ?? [];
        this.cooldown = options.cooldown ?? 0;
    }
    /**
     * Get an user ID from different sources, only here to simplify code.
     *
     * @param from - Where to get ID from.
     * @returns The ID.
     * @internal
     */
    static getSnowflake(from) {
        return from instanceof discord_js_1.Message ? from.author.id : from instanceof discord_js_1.User ? from.id : from instanceof discord_js_1.GuildMember ? from.user.id : from;
    }
    /**
     * Deletes a message if deletable.
     *
     * @param options - The options, see {@link DeleteMessageOptions}.
     * @returns The deleted message if deleted.
     */
    deleteMessage(options) {
        if (options.message.deletable)
            return options.message.delete(options.options);
    }
    /**
     * Returns the missing permissions from the client & user for a message.
     *
     * @param message - The message to check permissions for.
     * @returns The missing permissions.
     */
    getMissingPermissions(message) {
        const missingPermissions = {
            client: [],
            user: []
        };
        if (!message.guild || !message.guild.available)
            return missingPermissions;
        missingPermissions.client.push(...this.clientPermissions.filter(permission => {
            if (!(message.channel instanceof discord_js_1.DMChannel))
                return !message.channel.permissionsFor(message.guild?.me)?.has(permission, false);
        }));
        missingPermissions.user.push(...this.userPermissions.filter(permission => {
            if (!(message.channel instanceof discord_js_1.DMChannel))
                return !message.channel.permissionsFor(message.member)?.has(permission, false);
        }));
        if (message.guild.me?.hasPermission('ADMINISTRATOR'))
            missingPermissions.client = [];
        if (message.member?.hasPermission('ADMINISTRATOR'))
            missingPermissions.user = [];
        return missingPermissions;
    }
    /**
     * Returns the invalid permissions (not presents in {@link https://discord.js.org/#/docs/main/stable/class/Permissions?scrollTo=s-FLAGS | Permissions.FLAGS}).
     *
     * @returns The invalid permissions put in {@link clientPermissions} & {@link userPermissions}.
     * @internal
     */
    getInvalidPermissions() {
        const permissionsFlags = [...Object.keys(discord_js_1.Permissions.FLAGS)];
        return {
            user: this.userPermissions.filter(permission => !permissionsFlags.includes(permission)),
            client: this.clientPermissions.filter(permission => !permissionsFlags.includes(permission))
        };
    }
    /**
     * Gives the {@link tags} of this command which are not validated by the message.<br>
     * i.e. If a command is executed on a guild and the command has the `dmOnly` Tag, it will be returned.
     *
     * @param message - The message to test tags from.
     * @returns Tags that are not validated by the message.
     */
    getMissingTags(message) {
        const missingTags = [];
        for (const tag of this.tags) {
            if (tag === Tag.ownerOnly && !utils_1.isOwner(message.author.id))
                missingTags.push(Tag.ownerOnly);
            if (tag === Tag.nsfw && message.channel instanceof discord_js_1.GuildChannel && !message.channel.nsfw)
                missingTags.push(Tag.nsfw);
            if (tag === Tag.guildOnly && message.guild === null)
                missingTags.push(Tag.guildOnly);
            if (tag === Tag.guildOwnerOnly && message.guild?.ownerID !== message.author.id)
                missingTags.push(Tag.guildOwnerOnly);
            if (tag === Tag.dmOnly && message.channel.type !== 'dm')
                missingTags.push(Tag.dmOnly);
        }
        return missingTags;
    }
    /**
     * Returns false if {@link channels} are defined for this command but the message doesn't come from one of it.
     *
     * @param from - The message or channel to test where it comes from.
     * @returns If it is on a channel required if used.
     */
    isInRightChannel(from) {
        const channel = from instanceof discord_js_1.Message ? from.channel : from;
        if (this.channels.length === 0)
            return true;
        return this.channels.every(ch => {
            return ch instanceof discord_js_1.TextChannel ? channel.id === ch.id : false;
        });
    }
    /**
     * Returns true if the user is in a cooldown for this command.
     *
     * @remarks
     * If {@link cooldown} not set, this will always return `false`.
     *
     * @param from - From where to test if user is in a cooldown, see types.
     * @returns Is user in a cooldown.
     */
    isInCooldown(from) {
        const id = Command.getSnowflake(from);
        return CommandHandler_1.CommandHandler.cooldowns.has(id) && Object.keys(CommandHandler_1.CommandHandler.cooldowns.get(id)).includes(this.name);
    }
    /**
     * Get the actual cooldown of the user for this command plus when command has been executed and how many seconds to wait.
     *
     * @param from - Where to get the cooldown from, see types.
     * @returns The user's cooldown.
     */
    getCooldown(from) {
        const cooldown = CommandHandler_1.CommandHandler.cooldowns.get(Command.getSnowflake(from))[this.name];
        return {
            ...cooldown,
            waitMore: cooldown.executedAt.getTime() + cooldown.cooldown * 1000 - Date.now()
        };
    }
    /**
     * Put all the required properties in {@link CommandHandler.cooldowns} plus the `setTimeout` to remove the user from the cooldowns.
     *
     * @param from - What to use to select the user to set the cooldown from.
     */
    setCooldown(from) {
        const id = Command.getSnowflake(from);
        if (!CommandHandler_1.CommandHandler.cooldowns.has(id))
            CommandHandler_1.CommandHandler.cooldowns.set(id, {});
        if (this.cooldown === 0 ?? !!CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name])
            return;
        CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name] = {
            executedAt: from instanceof discord_js_1.Message ? from.createdAt : new Date(),
            cooldown: this.cooldown
        };
        setTimeout(() => {
            delete CommandHandler_1.CommandHandler.cooldowns.get(id)[this.name];
        }, this.cooldown * 1000);
    }
}
exports.Command = Command;
