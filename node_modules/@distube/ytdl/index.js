"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const ytdl_core_1 = __importDefault(require("ytdl-core"));
const prism_media_1 = require("prism-media");
const stream_1 = require("stream");
// ytdl events
const evn = ["info", "progress", "abort", "request", "response", "error", "redirect", "retry", "reconnect"];
// Opus Filter
const opusFilter = (format) => format.codecs === "opus" &&
    format.container === "webm" &&
    Number(format.audioSampleRate) === 48000;
;
;
/**
  * Create an opus stream for your video with provided encoder args
  * @param url - YouTube URL of the video or video info
  * @param options - YTDL options
  * @example const ytdl = require("discord-ytdl-core");
  * const stream = ytdl("VIDEO_URL", {
  *     seek: 3,
  *     encoderArgs: ["-af", "bass=g=10"],
  *     opusEncoded: true
  * });
  * VoiceConnection.play(stream, {
  *     type: "opus"
  * });
  */
const StreamDownloader = (url, options) => {
    if (!url) {
        throw new Error("No input url or videoInfo provided");
    }
    let FFmpegArgs = [
        "-analyzeduration", "0",
        "-loglevel", "0",
        "-f", `${options && options.fmt && typeof (options.fmt) == "string" ? options.fmt : "s16le"}`,
        "-ar", "48000",
        "-ac", "2"
    ];
    if (options && options.seek && !isNaN(options.seek)) {
        FFmpegArgs.unshift("-ss", options.seek.toString());
    }
    if (options && options.encoderArgs && Array.isArray(options.encoderArgs)) {
        FFmpegArgs = FFmpegArgs.concat(options.encoderArgs);
    }
    else if (typeof url !== "string" &&
        url.formats.find(opusFilter) &&
        !Number(options.seek) &&
        Number(url.videoDetails.lengthSeconds) > 0) {
        const demuxer = new prism_media_1.opus.WebmDemuxer();
        return stream_1.pipeline([
            ytdl_core_1.default.downloadFromInfo(url, options),
            demuxer,
        ], () => { });
    }
    const transcoder = new prism_media_1.FFmpeg({
        shell: false,
        args: FFmpegArgs
    });
    const inputStream = typeof url === "string" ? ytdl_core_1.default(url, options) : ytdl_core_1.default.downloadFromInfo(url, options);
    const output = inputStream.pipe(transcoder);
    if (options && !options.opusEncoded) {
        for (const event of evn) {
            inputStream.on(event, (...args) => output.emit(event, ...args));
        }
        inputStream.on("error", () => transcoder.destroy());
        output.on("close", () => transcoder.destroy());
        return output;
    }
    const opus = new prism_media_1.opus.Encoder({
        rate: 48000,
        channels: 2,
        frameSize: 960
    });
    const outputStream = output.pipe(opus);
    output.on('error', e => outputStream.emit('error', e));
    for (const event of evn) {
        inputStream.on(event, (...args) => outputStream.emit(event, ...args));
    }
    const _destroy = () => {
        if (!transcoder.destroyed)
            transcoder.destroy();
        if (!opus.destroyed)
            opus.destroy();
    };
    outputStream.on("close", _destroy).on("error", _destroy);
    return outputStream;
};
/**
 * Creates arbitraryStream
 * @param stream Any readable stream source
 * @param options Stream options
 * @example const streamSource = "https://listen.moe/kpop/opus";
 * let stream = ytdl.arbitraryStream(streamSource, {
 *     encoderArgs: ["-af", "asetrate=44100*1.25"],
 *     fmt: "mp3"
 * });
 *
 * stream.pipe(fs.createWriteStream("kpop.mp3"));
 */
const arbitraryStream = (stream, options) => {
    if (!stream) {
        throw new Error("No stream source provided");
    }
    let FFmpegArgs;
    if (typeof stream === "string") {
        FFmpegArgs = [
            '-reconnect', '1',
            '-reconnect_streamed', '1',
            '-reconnect_delay_max', '5',
            "-i", stream,
            "-analyzeduration", "0",
            "-loglevel", "0",
            "-f", `${options && options.fmt && typeof (options.fmt) == "string" ? options.fmt : "s16le"}`,
            "-ar", "48000",
            "-ac", "2"
        ];
    }
    else {
        FFmpegArgs = [
            "-analyzeduration", "0",
            "-loglevel", "0",
            "-f", `${options && options.fmt && typeof (options.fmt) == "string" ? options.fmt : "s16le"}`,
            "-ar", "48000",
            "-ac", "2"
        ];
    }
    if (options && options.seek && !isNaN(options.seek)) {
        FFmpegArgs.unshift("-ss", options.seek.toString());
    }
    if (options && options.encoderArgs && Array.isArray(options.encoderArgs)) {
        FFmpegArgs = FFmpegArgs.concat(options.encoderArgs);
    }
    let transcoder = new prism_media_1.FFmpeg({
        shell: false,
        args: FFmpegArgs
    });
    if (typeof stream !== "string") {
        transcoder = stream.pipe(transcoder);
        stream.on("error", () => transcoder.destroy());
    }
    if (options && !options.opusEncoded) {
        transcoder.on("close", () => transcoder.destroy());
        return transcoder;
    }
    ;
    const opus = new prism_media_1.opus.Encoder({
        rate: 48000,
        channels: 2,
        frameSize: 960
    });
    const outputStream = transcoder.pipe(opus);
    const _destroy = () => {
        if (!transcoder.destroyed)
            transcoder.destroy();
        if (!opus.destroyed)
            opus.destroy();
    };
    outputStream.on("close", _destroy).on("error", _destroy);
    return outputStream;
};
StreamDownloader.arbitraryStream = arbitraryStream;
StreamDownloader.version = require("./package.json").version;
const DiscordYTDLCore = Object.assign(StreamDownloader, ytdl_core_1.default);
module.exports = DiscordYTDLCore;
