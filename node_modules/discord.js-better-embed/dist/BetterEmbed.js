"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BetterEmbed = exports.limits = exports.templates = void 0;
const discord_js_1 = require("discord.js");
const path_1 = __importDefault(require("path"));
exports.templates = {
    basic: {
        footer: {
            text: '${client.user.username}',
            iconURL: '${client.user.displayAvatarURL()}',
        },
        timestamp: new Date(),
    },
    color: {
        color: '#4b5afd',
    },
    get complete() {
        return {
            ...this.basic,
            ...this.color,
            title: '${title}',
            description: '${description}',
        };
    },
    get image() {
        return {
            ...this.complete,
            image: {
                url: '${image}',
            },
        };
    },
};
exports.limits = {
    author: {
        name: 256,
    },
    title: 256,
    description: 4096,
    footer: {
        text: 2048,
    },
    fields: {
        size: 25,
        name: 256,
        value: 1024,
    },
};
class BetterEmbed extends discord_js_1.MessageEmbed {
    constructor(data) {
        super(data);
        this.checkSize();
    }
    static fromTemplate(template, values) {
        if (typeof template === 'string')
            if (exports.templates[template])
                template = exports.templates[template];
            else
                throw new Error(`Template '${template}' not found.`);
        template = JSON.parse(JSON.stringify(template));
        function setValues(object, values) {
            for (const [name, value] of Object.entries(object)) {
                if (!object.hasOwnProperty(name))
                    continue;
                if (Array.isArray(value))
                    object[name] = value.map(v => setValues(v, values));
                if (typeof value === 'object') {
                    object[name] = setValues(value, values);
                    continue;
                }
                const code = value.replace(/\$\{([^}]+)\}/gu, (_, value) => {
                    return values.hasOwnProperty(value.split('.')[0]) ? `\${values.${value}}` : value;
                });
                object[name] = eval(`\`${code}\``);
            }
            return object;
        }
        return new BetterEmbed(setValues(template, values));
    }
    checkSize(field) {
        if (!field) {
            const fields = {};
            function addField(name, content, limit) {
                fields[name] = {
                    content,
                    limit,
                };
            }
            if (this.title && this.title.length > exports.limits.title)
                addField('title', this.title, exports.limits.title);
            if (this.author?.name && this.author.name.length > exports.limits.author.name)
                addField('author', this.author.name, exports.limits.author.name);
            if (this.description && this.description.length > exports.limits.description)
                addField('description', this.description, exports.limits.description);
            if (this.fields?.length > exports.limits.fields.size)
                addField('fields', this.fields, exports.limits.fields.size);
            this.fields.forEach((field, index) => {
                if (field.name?.length > exports.limits.fields.name)
                    addField(`field[${index}]`, field.name, exports.limits.fields.name);
                if (field.value?.length > exports.limits.fields.value)
                    addField(`field[${index}]`, field.value, exports.limits.fields.value);
            });
            return fields;
        }
        switch (field) {
            case 'fields':
                if (this.fields?.length) {
                    return this.fields.length > exports.limits.fields.size;
                }
                else {
                    for (const field of this.fields) {
                        const index = this.fields.indexOf(field);
                        if (field.name.length > exports.limits.fields.name) {
                            return {
                                index,
                                name: true,
                                limit: exports.limits.fields.name,
                            };
                        }
                        else if (field.value.length > exports.limits.fields.value) {
                            return {
                                index,
                                value: true,
                                limit: exports.limits.fields.value,
                            };
                        }
                    }
                    return false;
                }
            case 'footer':
                return this.footer?.text ? this.footer.text.length > exports.limits.footer.text : true;
            case 'title':
                return this.title ? this.title?.length > exports.limits.title : true;
            case 'author':
                return this.author?.name ? this.author.name.length > exports.limits.author.name : true;
            case 'description':
                return this.description ? this.description.length > exports.limits.description : true;
            default:
                return true;
        }
    }
    setImageFromFile(link) {
        const attachment = new discord_js_1.MessageAttachment(link, path_1.default.basename(link));
        this.attachFiles([attachment]);
        this.setImage(`attachment://${attachment.name}`);
    }
    setThumbnailFromFile(link) {
        const attachment = new discord_js_1.MessageAttachment(link, path_1.default.basename(link));
        this.attachFiles([attachment]);
        this.setThumbnail(`attachment://${attachment.name}`);
    }
    throwIfTooLong(field) {
        if (field) {
            const tooLong = this.checkSize(field);
            if (!tooLong)
                return;
            switch (field) {
                case 'title':
                case 'author':
                case 'description':
                    if (field === 'author' ? !this.author?.name?.length : !this[field]?.length)
                        return;
                    const name = field === 'author' ? 'author.name' : field;
                    const limit = field === 'author' ? exports.limits.author.name : exports.limits[field];
                    const length = field === 'author' ? this.author.name.length : this[field].length;
                    throw new RangeError(`'embed.${name}' is too long: ${length} (max: ${limit}).`);
                case 'fields':
                    const tooLongFields = this.checkSize(field);
                    if (typeof tooLongFields === 'boolean')
                        throw new RangeError(`Too much fields (${exports.limits.fields.size}).`);
                    else {
                        const name = 'name' in tooLongFields ? 'value' : 'name';
                        // TODO : Find a fix for typings.
                        throw new RangeError(`'embed.fields[${tooLongFields.index}].${name}' is too long: ${tooLongFields[name].length}`);
                    }
            }
        }
        if (this.title && this.title.length > exports.limits.title)
            throw new RangeError(`'embed.title' is too long: ${this.title.length} (max: ${exports.limits.title}).`);
        if (this.author?.name && this.author.name.length > exports.limits.author.name)
            throw new RangeError(`'embed.author.name' is too long: ${this.author.name.length} (max: ${exports.limits.author.name}).`);
        if (this.description && this.description.length > exports.limits.description)
            throw new RangeError(`'embed.description' is too long: ${this.description.length} (max: ${exports.limits.description}).`);
        if (this.fields?.length > exports.limits.fields.size)
            throw new RangeError(`Too much fields (${exports.limits.fields.size}).`);
        this.fields.forEach(field => {
            if (field.name?.length > exports.limits.fields.name)
                throw new RangeError(`'embed.fields[${this.fields.indexOf(field)}].name' is too long: ${field.name.length} (max: ${exports.limits.fields.name}).`);
            if (field.value?.length > exports.limits.fields.value)
                throw new RangeError(`'embed.fields[${this.fields.indexOf(field)}].value' is too long: ${field.value.length} (max: ${exports.limits.fields.value}).`);
        });
    }
    cutIfTooLong() {
        function cutWithLength(text, maxLength) {
            return text.length > maxLength ? `${text.substring(0, maxLength - 3)}...` : text;
        }
        if (this.author?.name)
            this.author.name = cutWithLength(this.author.name, exports.limits.author.name);
        if (this.description)
            this.description = cutWithLength(this.description, exports.limits.description);
        if (this.title)
            this.title = cutWithLength(this.title, exports.limits.title);
        if (this.fields) {
            if (this.fields.length > exports.limits.fields.size)
                this.fields = this.fields.slice(0, exports.limits.fields.size) ?? [];
            this.fields.forEach(field => {
                field.name = cutWithLength(field.name ?? '', exports.limits.fields.name);
                field.value = cutWithLength(field.value ?? '', exports.limits.fields.value);
            });
        }
    }
}
exports.BetterEmbed = BetterEmbed;
BetterEmbed.LENGTH_LIMITS = exports.limits;
BetterEmbed.TEMPLATES = exports.templates;
